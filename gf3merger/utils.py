import os

import largestinteriorrectangle as lir
import matplotlib.pyplot as plt
import numpy as np
from scipy.signal import medfilt2d


def _read_res(slc_dir: str, query_keyword: str) -> str:
    """_READ_RES() is a function to read metadata value from slave.res file that
    is generated by DORIS.

    Parameters
    ----------
    slc_dir : str
        The SLC directory that contains slave.res file. For example, you could have
        `slc_dir = "stack/process/S01B01/20210225"`.
    query_keyword : str
        The keyword to query in slave.res file. Look for keywords in .res files
        that ends with semicolon.

    Returns
    -------
    str
        The content of the keyword. If the keyword is not found, ValueError will
        be raised.
    """
    fmeta = os.path.join(slc_dir, "slave.res")
    with open(fmeta, "r") as f:
        for line in f:
            if query_keyword in line:
                return line.split()[-1]

    raise ValueError(f"Cannot find {query_keyword} in {fmeta}")

def _read_rslc(
    slc_dir: str, lines: int | None = None, samples: int | None = None
) -> np.ndarray:
    """_READ_RSLC() is a function to read slave_rsmp.raw file generated by DORIS.
    Please note that this reads the COREGISTERED slave image, hence the "r"slc,
    where "r" stands for "resampled".

    Parameters
    ----------
    slc_dir : str
        Sames as _read_res(), The SLC directory that contains slave_rsmp.raw file.
    lines : int | None, optional
        Lines of the slave_rsmp.raw file. By default "slave.res" file in the same
        folder will be searched for getting the lines and samples of this image.
    samples : int | None, optional
        Samples of the salve_rsmp.raw file.

    Returns
    -------
    np.ndarray
        The 2D numpy array of the slave_rsmp.raw file in complext format.
    """

    # get the shape of the image
    if lines is None or samples is None:
        try:
            linestr = _read_res(slc_dir, "Last_line (w.r.t. original_master)")
            samplestr = _read_res(slc_dir, "Last_pixel (w.r.t. original_master)")
        except ValueError:
            linestr = _read_res(slc_dir, "Last_line (w.r.t. original_image)")
            samplestr = _read_res(slc_dir, "Last_pixel (w.r.t. original_image)")
        lines, samples = int(linestr), int(samplestr)

    shape = (lines, samples * 2)

    # read a binary file with numpy.memmap
    frslc = os.path.join(slc_dir, "slave_rsmp.raw")
    try:
        rslc_int = np.memmap(
            filename=frslc, dtype=np.int16, mode="r", offset=0, shape=shape
        )
    except ValueError as e:
        raise RuntimeError(f"Unable to read image {frslc} with dtype {np.int16}") from e

    # convert to complex64
    rslc = rslc_int[:, 0::2] + 1j * rslc_int[:, 1::2]

    return rslc

def _write_rslc(data, fout):

    dout = np.empty(data.size * 2, dtype=np.float64)
    dout[0::2] = data.flatten().real
    dout[1::2] = data.flatten().imag

    # write the data to disk in raw binary format and np.int16 using tofile()
    with open(fout, 'wb') as f:
        dout.astype(np.int16).tofile(f)

def find_common_overlap(
    parent_arr: np.ndarray,
    child_arr: np.ndarray,
    downsample_factor: int = 20,
    debug: bool = False,
) -> tuple[int, int, int, int]:
    """FIND_COMMON_OVERLAP() is a function to find the largest common overlap
    between two adjacent SLC images.

    Parameters
    ----------
    parent_arr : np.ndarray
    child_arr : np.ndarray
    downsample_factor : int, optional
        add a downsample factor to accelerate estimation process, by default 20
    debug : bool, optional

    Returns
    -------
    tuple[int, int, int, int]
        The (top, bottom, left, right) of the largest common overlap area.
    """

    buffer = 10

    # construct a mask of common overlap area
    common_overlap = np.logical_and(np.abs(parent_arr) > 0, np.abs(child_arr) > 0)
    # cpoy() is required to save array in contiguous memory
    common_overlap = np.copy(common_overlap[::downsample_factor, ::downsample_factor])
    # data-wash: filter out speckles in common overlap area
    common_overlap = medfilt2d(common_overlap.astype(int), kernel_size=11)
    # find largest interior rectangle
    corners = lir.lir(common_overlap.astype(bool))
    # take buffer into consideration
    corners = corners[0] + buffer, corners[1] + buffer, corners[2] - 2 * buffer, corners[3] - 2 * buffer

    if debug:
        plt.imshow(common_overlap)
        plt.savefig("common_overlap.png")

        largest_interior_rect = common_overlap * 0
        largest_interior_rect[
            corners[1] : corners[1] + corners[3], corners[0] : corners[0] + corners[2]
        ] = 10
        plt.imshow(largest_interior_rect)
        plt.savefig("largest_interior_rectangle.png")

    # upscale the corners back to original resolution
    corners = tuple(c * downsample_factor for c in corners)

    return corners[1], corners[1] + corners[3], corners[0], corners[0] + corners[2]

def plot_spectrum(slc_arr: np.ndarray, fname: str = "Spectrum.png"):
    mag = np.zeros(slc_arr.shape[0])

    # iterate over rows of the array
    for signal in slc_arr.T:
        # Compute FFT
        spectrum = np.fft.fftshift(np.fft.fft(signal))

        # Compute magnitude spectrum
        magnitude = np.abs(spectrum)

        mag += magnitude

    # Plot magnitude spectrum
    plt.clf()
    plt.plot(mag)
    plt.grid(True)
    plt.ylabel("Magnitude")
    plt.xlabel("Frequency (Hz)")
    plt.savefig(fname)
