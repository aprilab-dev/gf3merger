import os

import largestinteriorrectangle as lir
import numpy as np
from scipy.signal import medfilt2d


def _read_res(slc_dir: str, query_keyword: str) -> str:
    """_READ_RES() is a function to read metadata value from slave.res file that
    is generated by DORIS.

    Parameters
    ----------
    slc_dir : str
        The SLC directory that contains slave.res file. For example, you could have
        `slc_dir = "stack/process/S01B01/20210225"`.
    query_keyword : str
        The keyword to query in slave.res file. Look for keywords in .res files
        that ends with semicolon.

    Returns
    -------
    str
        The content of the keyword. If the keyword is not found, ValueError will
        be raised.
    """
    fmeta = os.path.join(slc_dir, "slave.res")
    with open(fmeta, "r") as f:
        for line in f:
            if query_keyword in line:
                return line.split()[-1]

    raise ValueError(f"Cannot find {query_keyword} in {fmeta}")


def _read_rslc(
    slc_dir: str, lines: int | None = None, samples: int | None = None
) -> np.ndarray:
    """_READ_RSLC() is a function to read slave_rsmp.raw file generated by DORIS.
    Please note that this reads the COREGISTERED slave image, hence the "r"slc,
    where "r" stands for "resampled".

    Parameters
    ----------
    slc_dir : str
        Sames as _read_res(), The SLC directory that contains slave_rsmp.raw file.
    lines : int | None, optional
        Lines of the slave_rsmp.raw file. By default "slave.res" file in the same
        folder will be searched for getting the lines and samples of this image.
    samples : int | None, optional
        Samples of the salve_rsmp.raw file.

    Returns
    -------
    np.ndarray
        The 2D numpy array of the slave_rsmp.raw file in complext format.
    """

    # get the shape of the image
    if lines is None or samples is None:
        lines = int(_read_res(slc_dir, "Last_line (w.r.t. original_master)"))
        samples = int(_read_res(slc_dir, "Last_pixel (w.r.t. original_master)"))
    shape = (lines, samples * 2)

    # read a binary file with numpy.memmap
    frslc = os.path.join(slc_dir, "slave_rsmp.raw")
    try:
        rslc_int = np.memmap(
            filename=frslc, dtype=np.int16, mode="r", offset=0, shape=shape
        )
    except ValueError as e:
        raise RuntimeError(f"Unable to read image {frslc} with dtype {np.int16}") from e

    # convert to complex64
    rslc = rslc_int[:, 0::2] + 1j * rslc_int[:, 1::2]

    return rslc


def find_common_overlap(
    parent_arr: np.ndarray, child_arr: np.ndarray, debug: bool = False
) -> tuple[int, int, int, int]:
    """FIND_COMMON_OVERLAP() is a function to find the largest common overlap
    between two adjacent SLC images.

    Parameters
    ----------
    parent_arr : np.ndarray
    child_arr : np.ndarray
    debug : bool, optional

    Returns
    -------
    tuple[int, int, int, int]
        The (top, bottom, left, right) of the largest common overlap area.
    """

    downsample_factor = 20

    common_overlap = np.logical_and(np.abs(parent_arr) > 0, np.abs(child_arr) > 0)

    # downsample the common_overlap area to speed up the calculation
    common_overlap = np.copy(common_overlap[::downsample_factor, ::downsample_factor])
    # filter out speckles in common overlap area
    common_overlap = medfilt2d(common_overlap.astype(int), kernel_size=7)
    # find largest interior rectangle
    corners = lir.lir(common_overlap.astype(bool))

    if debug:
        import matplotlib.pyplot as plt

        plt.imshow(common_overlap)
        plt.savefig("common_overlap.png")

        largest_interior_rect = common_overlap * 0
        largest_interior_rect[
            corners[1] : corners[1] + corners[3], corners[0] : corners[0] + corners[2]
        ] = 10
        plt.imshow(largest_interior_rect)
        plt.savefig("largest_interior_rectangle.png")

    return corners[1], corners[1] + corners[3], corners[0], corners[0] + corners[2]
